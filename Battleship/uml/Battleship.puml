@startuml
skinparam style strictuml
skinparam classAttributelconSize 0
skinparam classFontStyle bold
hide enum methods
skinparam linetype ortho

package view
{
    class TerminalHistory
        {
            +<<create>>TerminalHistory()
            +updateAttack(pos : Integer, weapon : Weapon)
        }

        class ConfigurationScreen
        {
            +<<create>>ConfigurationScreen()
        }

        class PlacementScreen
        {
            +<<create>>PlacementScreen()
            +updateShipPlaced(ship : Ship)
            +updateTrapPlaced(trap : Trap)
            +updateWeaponPlaced(weapon : Weapon)
        }

        class MainScreen
        {
            +<<create>>MainScreen()
            +updateTrapPlaced(trap : Trap)
            +updateAttack(pos : Integer, weapon : Weapon)
            +updateEffectApplied(effect : Effects)
            +updateNumberOfShips(numberOfShips: Integer)
            +updateTurnNumber(turnNumber: Integer)
            +updateTileHit(pos: Integer)
        }

        class EndScreen
        {
            +<<create>>EndScreen()
            +updateTurnNumber(turnNumber: Integer)
            +updateTileHit(pos: Integer)
        }
}

package controller
{
    class ScreenController implements .model.game.GameObserver
    {
        +updateGameState(gamestate: GameState)
    }
    class GameController
    {

    }
    class PlacementController
    {

    }
    class ConfigController
    {

    }
}

package model
{
    package grid
    {
        class Grid
        {
            -m_size : Integer
            +<<create>>Grid(size : Integer)
            +hitTile(pos:Integer)
            +placeObject(object : PlaceableObject)
            +attackAt(pos : Integer, Weapon weapon) : PlaceableObject
            +addObserver(obs : GridObserver)
            +removeObserver(obs : GridObserver)
            +notifyTileHit(pos : Integer)
            +getTile(pos : Integer) : Tile
        }

        interface GridObserver <<interface>>
        {
            +updateTileHit(pos: Integer)
        }

        class Tile
        {
            -m_isHit : Boolean
            +<<create>>Tile(type : TileType)
            +getObject() : PlaceableObject
            +getTileType() : TileType
            +getIsHit() : Boolean
            +setObject(object : PlaceableObject)
            +hit()
        }
        enum TileType
        {
            WATER
            LAND
        }
    }
    package PlaceableObject
    {
        abstract PlaceableObject <<abstract>>
        {
            -m_position : Integer
            +getPosition()
            +setPosition(pos:Integer)

        }

        enum PlaceableObjectType
        {
            SHIP
            TRAP
            WEAPON
        }
        package trap
        {
            class Trap <<abstract>> implements model.PlaceableObject.PlaceableObject
            {
                +<<create>>Trap()
                +activate(opponentGrid : Grid)
            }

            interface TrapFactory
            {
                +createTrap(trapType : TrapType) : Trap
            }

            class Blackhole extends Trap
            {
                +<<create>>Blackhole()
                +activate(player : Player,pos : Integer)
            }
            class Tornado extends Trap
            {
                'An integer initialized to 0 will be created in the constructor, and each call to Scramble will increment this integer
                'by 1 until it reaches 3 (or a multiple of 3 if multiple Tornado traps can be placed on the same grid)
                -remainingScrambles : Integer
                +<<create>>Tornado()
                +activate(player : Player)
                +scramble(opponentGrid : Grid)
                +getRemainingScrambles() : Integer
                +isExpired() : Boolean
            }
            enum trapType{
                BLACKHOLE
                TORNADO
            }
        }
        package ship
        {
            class Ship <<abstract>> implements model.PlaceableObject.PlaceableObject
            {
                -m_size : Integer
                -m_hp : Integer
                +<<create>> Ship(size : Integer, type : ShipType)
                'm_hp = size we don't need the information twice
                +isDestroyed() : Boolean
                +getHp() : Integer
                +getSize() : Integer
                +getDirection() : Direction
                +getShipType() : ShipType
                +setDirection(direction : Direction)
                +setHp(newhp : Integer)
                +hit()
                'We will only know the direction when placing the boat not during the creation
            }
            interface ShipFactory
            {
                +createShip(shipType : ShipType) : Ship
            }
            class AircraftCarrier extends Ship
            {
                +<<create>> AircraftCarrier()
            }
            class Cruiser extends Ship
            {
                +<<create>> Cruiser()
            }
            class Destroyer extends Ship
            {
                +<<create>> Destroyer()
            }
            class Submarine extends Ship
            {
                +<<create>> Submarine()
            }
            class TorpedoBoat extends Ship
            {
                +<<create>> TorpedoBoat()
            }
            enum ShipType
            {
                AIRCRAFTCARRIER
                CRUISER
                DESTROYER
                SUBMARINE
                TORPEDOBOAT
            }
            enum Direction
            {
                HORIZONTAL
                VERTICAL
            }
        }
        package weapon
        {
            class Weapon <<abstract>> implements model.PlaceableObject.PlaceableObject
            {
                +<<create>>Weapon(type : WeaponType)
                +use(opponentGrid : Grid, pos : Integer)
            }
            interface WeaponFactory
            {
                +createWeapon(weaponType : WeaponType) : Weapon
            }
            class Default extends Weapon
            {
                +<<create>>Default()
                +use(opponentGrid : Grid, pos : Integer) : Boolean
            }
            class Bomb extends Weapon
            {
                +<<create>>Bomb()
                +use(opponentGrid : Grid, pos : Integer) : Boolean
            }
            class Sonar extends Weapon
            {
                +<<create>>Sonar()
                +use(opponentGrid : Grid, pos : Integer) : Booolean
            }
            enum WeaponType
            {
                MISSILE
                BOMB
                SONAR
            }
        }
    }
    package player
    {
        class Player <<abstract>>
        {
            #m_name : String
            #m_isTornadoed : Boolean
            +<<create>>Player(name : String, grid : Grid)
            +placeObject(object : PlaceableObject)
            +placeShipFix()
            +placeShipRandom()
            +placeTrapFix()
            +placeTrapRandom()
            +placeWeaponFix()
            +placeWeaponRandom()
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +setIsTornadoed(isAffected : Boolean)
            +attack(opponent : Player, pos : Integer)
            +addObserver(observer : PlayerObserver)
            +removeObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +getName() : String
            +getGrid() : Grid
        }
        class Human extends Player
        {
            +<<create>>Human(grid : Grid)
            +placeFix()
            +placeBoatCustom(pos : Integer, ship : Ship)
            +placeTrapCustom(pos : Integer, trap : Trap)
            +placeWeaponCustom(pos : Integer, weapon : Weapon)
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +removeObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }
        class AI extends Player
        {
            +<<create>>AI(grid : Grid)
            +placeBoatFix()
            +placeTrapFix()
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +removeObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +attackRandom(opponentGrid : Grid,weapon : Weapon)
            +attackWithTought(opponentGrid: Grid,weapon : Weapon)
            +attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }

        enum difficulty
        {
            RANDOM
            THOUGHT
        }
        interface PlayerObserver
        {
            +updateShips(ships : Ship[*])
            +updateTraps(traps : Trap[*])
            +updateWeapons(weapons : Weapon[*])
            +updateAttack(pos : Integer, weapon : Weapon)
        }
    }
    package game
    {
        class Game
        {
            -m_turnNumber : Integer
            +<<create>> Game()
            +startGame()
            +nextTurn()
            +checkWin() : Boolean
            +getGameState() : GameState
            +getTurnNumber() : Integer
            +addObserver(obs : GameObserver)
            +removeObserver(obs : GameObserver)
            +notifyGameState(gamestate: GameState)
            +notifyTurnNumber(turnNumber: Integer)
        }
        enum GameState
        {
            CONFIGURATION,
            PLACEMENT,
            PLAYING,
            END
        }
        interface GameObserver <<interface>>
        {
            +updateGameState(gamestate: GameState)
            +updateTurnNumber(turnNumber: Integer)
        }
        class MoveData {
            -m_position : Integer
            -m_hit : Boolean
        }
    }
}
'PlaceableObject relations
model.PlaceableObject.PlaceableObjectType .> model.PlaceableObject.PlaceableObject : <<uses>>

'Game relations
model.game.Game "1" *--> "-m_gameState" model.game.GameState: > is currently in
model.game.Game "2" o--> "-m_players" model.player.Player: > is played bys
model.game.Game "1" o--> "-m_currentPlayer" model.player.Player : > current turn
model.game.Game "*" o--> "-m_gameObservers" model.game.GameObserver : > notifies
model.game.Game "*" o--> "-m_moveHistory" model.game.MoveData : > has been played

'MoveData relations
model.game.MoveData "1" o--> "-m_player" model.player.Player: > move played by
model.game.MoveData "1" o--> "-m_weapon" model.PlaceableObject.weapon.WeaponType: > move attacked with

'Grid relations
model.grid.Grid "*" *--> "-m_grid" model.grid.Tile : > is made of
model.grid.Grid "*" o--> "-m_gridObservers" model.grid.GridObserver : > notify

'Tile relations
model.grid.Tile "1" *--> "-m_object" model.PlaceableObject.PlaceableObject: > has elements of the type
model.grid.Tile "1" *->  "-m_tileType" model.grid.TileType : > is of the type\t

'Ship relations
model.PlaceableObject.ship.Ship "1" o--> "-m_shipTyÑ€e" model.PlaceableObject.ship.ShipType: > is of the type
model.PlaceableObject.ship.Ship "1" o--> "-m_direction" model.PlaceableObject.ship.Direction: > is in this direction

'Weapon relations
model.PlaceableObject.weapon.Weapon ..> model.grid.Grid : <<uses>>

'Blackhole relations
model.PlaceableObject.trap.Blackhole ..> model.PlaceableObject.weapon.Default : <<uses>>
model.PlaceableObject.trap.Blackhole ..> model.grid.Grid : <<uses>>

'Tornado relations
model.PlaceableObject.trap.Tornado ..> model.grid.Grid : <<uses>>
model.PlaceableObject.trap.Tornado ..> model.player.Player : <<uses>>

'Player relations
model.player.Player "1" *--> "#m_grid" model.grid.Grid : > places on
model.player.Player "*" *--> "#m_ships" model.PlaceableObject.ship.Ship : > owns
model.player.Player "*" *--> "#m_traps" model.PlaceableObject.trap.Trap : > owns
model.player.Player "*" *--> "#m_weapons" model.PlaceableObject.weapon.Weapon : > owns
model.player.Player "1" o--> "#m_weaponStrategy" model.PlaceableObject.weapon.Weapon : > uses the strategy
model.player.Player "1..*" o--> "#m_observers" model.player.PlayerObserver : > notifies changes

'AI relations
model.player.difficulty .> model.player.AI : <<uses>>

'ShipFactory relations
model.PlaceableObject.ship.ShipFactory ..> model.PlaceableObject.ship.Ship : <<uses>>
model.PlaceableObject.ship.ShipFactory ..> model.PlaceableObject.ship.Submarine : <<instantiate>>
model.PlaceableObject.ship.ShipFactory ..> model.PlaceableObject.ship.TorpedoBoat : <<instantiate>>
model.PlaceableObject.ship.ShipFactory ..> model.PlaceableObject.ship.Cruiser : <<instantiate>>
model.PlaceableObject.ship.ShipFactory ..> model.PlaceableObject.ship.Destroyer : <<instantiate>>
model.PlaceableObject.ship.ShipFactory ..> model.PlaceableObject.ship.AircraftCarrier : <<instantiate>>

'WeaponFactory relations
model.PlaceableObject.weapon.WeaponFactory .> model.PlaceableObject.weapon.Weapon : <<uses>>
model.PlaceableObject.weapon.WeaponFactory .> model.PlaceableObject.weapon.Bomb : <<instantiate>>
model.PlaceableObject.weapon.WeaponFactory .> model.PlaceableObject.weapon.Sonar : <<instantiate>>
model.PlaceableObject.weapon.WeaponFactory .> model.PlaceableObject.weapon.Default : <<instantiate>>

'TrapFactory relations
model.PlaceableObject.trap.TrapFactory .> model.PlaceableObject.trap.Trap : <<uses>>
model.PlaceableObject.trap.TrapFactory .> model.PlaceableObject.trap.Blackhole : <<instantiate>>
model.PlaceableObject.trap.TrapFactory .> model.PlaceableObject.trap.Tornado : <<instantiate>>

' EndScreen observe aussi la grille
EndScreen ..|> model.grid.GridObserver
MainScreen ..|> model.grid.GridObserver

' View relations

view.ConfigurationScreen ..|> model.game.GameObserver
view.PlacementScreen ..|> model.game.GameObserver
view.MainScreen ..|> model.game.GameObserver
view.EndScreen ..|> model.game.GameObserver
view.TerminalHistory .up.|> .model.player.PlayerObserver
view.PlacementScreen .up.|> .model.player.PlayerObserver
view.MainScreen .up.|> .model.player.PlayerObserver
view.EndScreen .up.|> .model.player.PlayerObserver

@enduml