@startuml
skinparam style strictuml
skinparam classAttributelconSize 0
skinparam classFontStyle bold
hide enum methods
skinparam linetype ortho

package view
{
    class TerminalHistory
        {
            +<<create>>TerminalHistory()
            +updateAttack(pos : Integer, weapon : Weapon)
        }

        class ConfigurationScreen
        {
            +<<create>>ConfigurationScreen()
        }

        class PlacementScreen
        {
            +<<create>>PlacementScreen()
            +updateShipPlaced(ship : Ship)
            +updateTrapPlaced(trap : Trap)
            +updateWeaponPlaced(weapon : Weapon)
        }

        class MainScreen
        {
            +<<create>>MainScreen()
            +updateTrapPlaced(trap : Trap)
            +updateAttack(pos : Integer, weapon : Weapon)
            +updateEffectApplied(effect : Effects)
            +updateNumberOfShips(numberOfShips: Integer)
            +updateTurnNumber(turnNumber: Integer)
            +updateTileHit(pos: Integer)
        }

        class EndScreen
        {
            +<<create>>EndScreen()
            +updateTurnNumber(turnNumber: Integer)
            +updateTileHit(pos: Integer)
        }
        class MainView
        {
            +<<create>>MainView()
            +updateGameState(gamestate: GameState)
        }
}

package controller
{
    class ScreenController implements .model.game.GameObserver
    {
        +updateGameState(gamestate: GameState)
    }
    class BattleController
    {

    }
    class PlacementController
    {

    }
    class ConfigController
    {

    }

    class HumanController
    {
        +setGameController(gameController : GameController)
        +setPlayer(p : Player)
        +getPlayer() : Player
        +startTurn()
        +handleTileClick(target : Player, pos : Integer)
        +handleWeaponEquip(weaponType : WeaponType)
        +onAttackFinished()
    }
    class AIController
    {
        +setGameController(gameController : GameController)
        +setPlayers(aiPlayer : Player, humanPlayer : Player)
        +getPlayer() : Player
        +startTurn()
        +onAttackFinished()
    }

    interface TurnObserver <<interface>>{
        + onTurnEnded(Player p)
    }

    abstract class AbstractPlayerController <<abstract>>{
        # m_player : Player
        # m_observers : List<TurnObserver>
        + addObserver(TurnObserver)
        + removeObserver(TurnObserver)
        # notifyTurnEnded()
        + onAttackFinished()
        {abstract} + startTurn()
    }
}

package model
{
    package grid
    {
        class Grid
        {
            -m_size : Integer
            +<<create>>Grid(size : Integer)
            +hitTile(pos:Integer)
            +putPlaceObjectInTile(object : PlaceableObject)
            +attackAt(pos : Integer, Weapon weapon) : PlaceableObject
            +addObserver(obs : GridObserver)
            +notifyTileHit(pos : Integer)
            +getTile(pos : Integer) : Tile
            +getSize() : Integer
            +isTileHit(pos : Integer) : Boolean
            +isLand(pos : Integer) : Boolean
            +getObjectAt(pos : Integer) : PlaceableObject
            +setTileHit(pos : Integer)
            -isValidPos(pos : Integer) : Boolean
            +reset()
            +getLandTiles() : Integer[*]
        }

        interface GridObserver <<interface>>
        {
            +updateTileHit(pos: Integer)
        }

        class Tile
        {
            -m_isHit : Boolean
            +<<create>>Tile(type : TileType)
            +hit()
            +isHit() : Boolean
            +isLand() : Boolean
            +getTileType() : TileType
            +getObject() : PlaceableObject
            +setObject(object : PlaceableObject)
            +isEmpty() : Boolean
            +reset()
        }
        enum TileType
        {
            WATER
            LAND
        }
    }
    package placeableObject
    {
        abstract PlaceableObject <<abstract>>
        {
            -m_position : Integer
            +getPosition()
            +setPosition(pos:Integer)
            +getObjectType():PlaceableObjectType
        }

        enum PlaceableObjectType
        {
            SHIP
            TRAP
            WEAPON
        }
        package trap
        {
            class Trap <<abstract>> implements model.placeableObject.PlaceableObject
            {
                +<<create>>Trap()
                +activate(opponentGrid : Grid)
            }

            interface TrapFactory
            {
                +createTrap(trapType : TrapType) : Trap
            }

            class Blackhole extends Trap
            {
                +<<create>>Blackhole()
                +activate(player : Player,pos : Integer)
            }
            class Tornado extends Trap
            {
                'An integer initialized to 0 will be created in the constructor, and each call to Scramble will increment this integer
                'by 1 until it reaches 3 (or a multiple of 3 if multiple Tornado traps can be placed on the same grid)
                -remainingScrambles : Integer
                +<<create>>Tornado()
                +activate(player : Player)
                +scramble(opponentGrid : Grid)
                +getRemainingScrambles() : Integer
                +isExpired() : Boolean
            }
            enum TrapType{
                BLACKHOLE
                TORNADO
            }
        }
        package ship
        {
            class Ship <<abstract>> implements model.placeableObject.PlaceableObject
            {
                -m_size : Integer
                -m_hp : Integer
                +<<create>> Ship(size : Integer, type : ShipType)
                'm_hp = size we don't need the information twice
                +isDestroyed() : Boolean
                +getHp() : Integer
                +getSize() : Integer
                +getDirection() : Direction
                +getShipType() : ShipType
                +setDirection(direction : Direction)
                +setHp(newhp : Integer)
                +hit()
                +getAllPositions():Integer[*]
                'We will only know the direction when placing the boat not during the creation
            }
            interface ShipFactory
            {
                +createShip(shipType : ShipType) : Ship
            }
            class AircraftCarrier extends Ship
            {
                +<<create>> AircraftCarrier()
            }
            class Cruiser extends Ship
            {
                +<<create>> Cruiser()
            }
            class Destroyer extends Ship
            {
                +<<create>> Destroyer()
            }
            class Submarine extends Ship
            {
                +<<create>> Submarine()
            }
            class TorpedoBoat extends Ship
            {
                +<<create>> TorpedoBoat()
            }
            enum ShipType
            {
                AIRCRAFTCARRIER
                CRUISER
                DESTROYER
                SUBMARINE
                TORPEDOBOAT
            }
            enum Direction
            {
                HORIZONTAL
                VERTICAL
            }
        }
        package weapon
        {
            class Weapon <<abstract>> extends model.placeableObject.PlaceableObject
            {
                +<<create>>Weapon(type : WeaponType)
                +use(opponentGrid : Grid, pos : Integer)
                {abstract} +use(grid : Grid, pos : Integer)
                +setCallback(callback : WeaponCallback)
                +notifyFinished()
                +getType() : WeaponType
            }
            interface WeaponFactory
            {
                +createWeapon(weaponType : WeaponType) : Weapon
            }
            class Default extends Weapon
            {
                +<<create>>Default()
                +use(opponentGrid : Grid, pos : Integer) : Boolean
            }
            class Bomb extends Weapon
            {
                +<<create>>Bomb()
                +getType() : WeaponType
                +use(opponentGrid : Grid, pos : Integer) : Boolean
                +isInsideGrid(x : Integer, y : Integer, size : Integer) : Boolean
            }
            class Sonar extends Weapon
            {
                +<<create>>Sonar()
                +use(opponentGrid : Grid, pos : Integer) : Booolean
            }
            enum WeaponType
            {
                MISSILE
                BOMB
                SONAR
            }
        }
    }
    package player
    {
        class Player <<abstract>>
        {
            #m_name : String
            #m_isTornadoed : Boolean
            +<<create>>Player(name : String, grid : Grid)
            +placeObject(object : PlaceableObject)
            +placeShipFix()
            +placeShipRandom()
            +placeTrapFix()
            +placeTrapRandom()
            +placeWeaponFix()
            +placeWeaponRandom()
            +setWeaponStrategy(weapon : Weapon)
            +equipWeapon(targetType : WeaponType) : Boolean
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +setIsTornadoed(isAffected : Boolean)
            +attack(opponent : Player, pos : Integer)
            +addObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +getName() : String
            +getGrid() : Grid
            +getWeaponStrategy() : Weapon
            +allShipsAreSunk() : boolean
        }
        class Human extends Player
        {
            +<<create>>Human(grid : Grid)
            +placeFix()
            +placeBoatCustom(pos : Integer, ship : Ship)
            +placeTrapCustom(pos : Integer, trap : Trap)
            +placeWeaponCustom(pos : Integer, weapon : Weapon)
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }
        class AI extends Player
        {
            +<<create>>AI(grid : Grid)
            +placeBoatFix()
            +placeTrapFix()
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +attackRandom(opponentGrid : Grid,weapon : Weapon)
            +attackWithTought(opponentGrid: Grid,weapon : Weapon)
            +attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }

        enum difficulty
        {
            RANDOM
            THOUGHT
        }
        interface PlayerObserver
        {
            +updateShips(ship : Ship)
            +updateTraps(trap : Trap)
            +updateWeapons(weapon : Weapon)
            +updateAttack(pos : Integer, weapon : Weapon)
        }
    }
    package game
    {
        class Game
        {
            -m_turnNumber : Integer
            -m_currentPlayer : Integer
            -m_winner : Player
            +<<create>> Game()
            +createStandardFleet(factory : ShipFactory) : Ship[]
            +recordMove(player : Player, position : Integer, weapon : WeaponType, isHit : Boolean)
            +startGame()
            +startPlacement()
            +startBattle()
            +nextTurn()
            +checkWin() : Boolean
            +stopGame(winner : Player)
            +getWinner() : Player
            +getGameState() : GameState
            +getTurnNumber() : Integer
            +getHumanPlayer() : Player
            +getAiPlayer() : Player
            +addObserver(obs : GameObserver)
            +notifyGameState(gamestate: GameState)
            +notifyTurnNumber(turnNumber: Integer)
            +notifyHistory(message : String)
            +restart()
        }
        enum GameState
        {
            CONFIGURATION,
            PLACEMENT,
            PLAYING,
            END
        }
        interface GameObserver <<interface>>
        {
            +updateGameState(gamestate: GameState)
            +updateTurnNumber(turnNumber: Integer)
            +updateHistory(logMessage: String)
        }
        class MoveData {
            -m_position : Integer[*]
            -m_m_isHit : Boolean[*]
            +<<create>> MoveData()
            +addData(position : Integer, hit : Integer, player : Player, weapon : WeaponType)
        }

        interface WeaponCallback <<interface>>{
            + onAttackFinished()
        }
    }
}
'PlaceableObject relations
model.placeableObject.PlaceableObject "1" *->  "-m_objectType" model.placeableObject.PlaceableObjectType : > is of the type\t
'Game relations
model.game.Game "1" *--> "-m_gameState" model.game.GameState: > is currently in
model.game.Game "2" o--> "-m_players" model.player.Player: > is played by
model.game.Game "*" o--> "-m_gameObserver" model.game.GameObserver : > notifies
model.game.Game "1" *--> "-m_moveHistory" model.game.MoveData : > has been played
model.game.Game "0..1" --> "-m_winner" model.player.Player : > has winner

'MoveData relations
model.game.MoveData "*" o--> "-m_player" model.player.Player: > move played by
model.game.MoveData "*" *--> "-m_weapon" model.placeableObject.weapon.WeaponType: > move attacked with
model.game.MoveData ..> model.placeableObject.weapon.WeaponFactory : <<uses>>

'Grid relations
model.grid.Grid "1" *--> "-m_grid" model.grid.Tile : > is made of
model.grid.Grid "*" o--> "-m_gridObservers" model.grid.GridObserver : > notify

'Tile relations
model.grid.Tile "0..1" *--> "-m_object" model.placeableObject.PlaceableObject: > has elements of the type
model.grid.Tile "1" *->  "-m_tileType" model.grid.TileType : > is of the type\t

'Ship relations
model.placeableObject.ship.Ship "1" o--> "-m_shipTyÑ€e" model.placeableObject.ship.ShipType: > is of the type
model.placeableObject.ship.Ship "1" o--> "-m_direction" model.placeableObject.ship.Direction: > is in this direction

'Weapon relations
model.placeableObject.weapon.Weapon ..> model.grid.Grid : <<uses>>
model.placeableObject.weapon.Weapon "1" *->  "-m_weaponType" model.placeableObject.weapon.Weapon : > is of the type\t
model.placeableObject.weapon.Weapon "1" *->  "-m_callback" model.game.WeaponCallback : > calls back\t

'Trap relations
model.placeableObject.trap.Trap "1" *->  "-m_trapType" model.placeableObject.trap.TrapType : > is of the type

'Blackhole relations
model.placeableObject.trap.Blackhole ..> model.placeableObject.weapon.Default : <<uses>>
model.placeableObject.trap.Blackhole ..> model.grid.Grid : <<uses>>

'Tornado relations
model.placeableObject.trap.Tornado ..> model.grid.Grid : <<uses>>
model.placeableObject.trap.Tornado ..> model.player.Player : <<uses>>

'Player relations
model.player.Player "1" *--> "#m_grid" model.grid.Grid : > places on
model.player.Player "*" *--> "#m_ships" model.placeableObject.ship.Ship : > owns
model.player.Player "*" *--> "#m_traps" model.placeableObject.trap.Trap : > owns
model.player.Player "*" *--> "#m_weapons" model.placeableObject.weapon.Weapon : > owns
model.player.Player "1" o--> "#m_weaponStrategy" model.placeableObject.weapon.Weapon : > uses the strategy
model.player.Player "1..*" o--> "#m_observers" model.player.PlayerObserver : > notifies changes
model.player.Player ..> model.placeableObject.weapon.WeaponType : <<uses>>

'AI relations
model.player.difficulty .> model.player.AI : <<uses>>

'ShipFactory relations
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Ship : <<uses>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Submarine : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.TorpedoBoat : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Cruiser : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Destroyer : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.AircraftCarrier : <<instantiate>>

'WeaponFactory relations
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Weapon : <<uses>>
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Bomb : <<instantiate>>
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Sonar : <<instantiate>>
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Default : <<instantiate>>

'TrapFactory relations
model.placeableObject.trap.TrapFactory .> model.placeableObject.trap.Trap : <<uses>>
model.placeableObject.trap.TrapFactory .> model.placeableObject.trap.Blackhole : <<instantiate>>
model.placeableObject.trap.TrapFactory .> model.placeableObject.trap.Tornado : <<instantiate>>

' EndScreen also observes the gird
EndScreen ..|> model.grid.GridObserver
MainScreen ..|> model.grid.GridObserver

' View relations

view.ConfigurationScreen ..|> model.game.GameObserver
view.PlacementScreen ..|> model.game.GameObserver
view.MainScreen ..|> model.game.GameObserver
view.EndScreen ..|> model.game.GameObserver
view.MainView ..|> model.game.GameObserver
view.TerminalHistory .up.|> .model.player.PlayerObserver
view.PlacementScreen .up.|> .model.player.PlayerObserver
view.MainScreen .up.|> .model.player.PlayerObserver
view.EndScreen .up.|> .model.player.PlayerObserver

'Controller relations

'AbstractPlayerController relations
controller.AbstractPlayerController ..|> model.game.WeaponCallback
controller.AbstractPlayerController o--> "0..*" controller.TurnObserver : > notifies

'AIController relations
controller.AIController --|> controller.AbstractPlayerController
controller.AIController "1" o--> "-gameController" controller.GameController : > notifies end of turn
controller.AIController "1" o--> "-m_ai" model.player.Player : > controls
controller.AIController "1" o--> "-m_opponent" model.player.Player : > targets
controller.AIController ..> model.placeableObject.weapon.Weapon : <<uses>>
controller.AIController ..> model.placeableObject.weapon.WeaponType : <<uses>>


'HumanController relations
controller.HumanController --|> controller.AbstractPlayerController
controller.HumanController "1" o--> "-gameController" controller.GameController : > notifies end of turn
controller.HumanController "1" o--> "-m_player" model.player.Player : > controls
controller.HumanController ..> model.placeableObject.weapon.Weapon : <<uses>>
controller.HumanController ..> model.placeableObject.weapon.WeaponType : <<uses>>

'GameController relations
controller.GameController ..|> controller.TurnObserver
controller.GameController "1" o--> "-m_humanController" controller.HumanController : > coordinates
controller.GameController "1" o--> "-m_aiController" controller.AIController : > coordinates
controller.GameController "1" o--> "-m_currentPlayer" model.player.Player : > tracks active player
controller.GameController ..> model.placeableObject.weapon.WeaponType : <<uses>>
controller.GameController "1" o--> "-m_game" model.game.Game : > is the active game
@enduml