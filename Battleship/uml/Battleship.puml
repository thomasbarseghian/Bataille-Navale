@startuml
skinparam style strictuml
skinparam classAttributelconSize 0
skinparam classFontStyle bold
hide enum methods
skinparam linetype ortho

package view
{
    class TerminalHistory
        {
            +<<create>>TerminalHistory()
            +updateAttack(pos : Integer, weapon : Weapon)
        }

        class ConfigurationScreen
        {
            +<<create>>ConfigurationScreen()
        }

        class PlacementScreen
        {
            +<<create>>PlacementScreen()
            +updateShipPlaced(ship : Ship)
            +updateTrapPlaced(trap : Trap)
            +updateWeaponPlaced(weapon : Weapon)
        }

        class MainScreen
        {
            +<<create>>MainScreen()
            +updateTrapPlaced(trap : Trap)
            +updateAttack(pos : Integer, weapon : Weapon)
            +updateEffectApplied(effect : Effects)
        }

        class EndScreen
        {
            +<<create>>EndScreen()
        }
} 

package controller
{
    class ScreenController
    {

    }
    class GameController
    {

    }
    class PlacementController
    {

    }
    class ConfigController
    {

    }
}

package model
{
    package grid
    {
        class Grid
        {
            -m_size : Integer
            -m_miss : Integer
            -m_hit : Integer
            -m_islandTileSearched : Integer
            +<<create>>Grid(size : Integer)
            +PlaceObject(object : PlacableObject, pos : Integer)
            +getMiss() : Integer
            +getHit() : Integer
            +getIslandTileSearched() : Integer
            +Miss()
            +Hit()
            +Search()
        }

        class Tile
        {
            -isHit : Boolean
            +<<create>>Tile(type : TileType, object : PlacableObject)
            +getObject() : PlacableObject
            +getTileType() : TileType
            +setObject(object : PlacableObject)
        }
        enum TileType
        {
            WATER
            LAND
        }
    }
    package placableObject
    {
        interface PlacableObject <<interface>>
        {

        }
        class Trap <<abstract>> implements PlacableObject
        { 
            +<<create>>Trap()
            +Activate()
        }

        interface TrapFactory
        {
            +createTrap(trapType : TrapType) : Trap
        }

        class Blackhole extends Trap
        { 
            +<<create>>Blackhole()
            +Activate(opponentGrid : Grid, pos : Integer)
        }
        class Tornado extends Trap
        {
            'An integer initialized to 0 will be created in the constructor, and each call to Scramble will increment this integer
            'by 1 until it reaches 3 (or a multiple of 3 if multiple Tornado traps can be placed on the same grid)
            +<<create>>Tornado()
            +Activate(player : Player)
            +Scramble(opponentGrid : Grid)
        }
        class Ship <<abstract>> implements PlacableObject
        {
            -m_size : Integer
            -m_hp : Integer
            -m_shipTiles : Integer
            +<<create>> Ship(size : Integer, type : ShipType)
            'm_hp = size we don't need the information twice
            +isDestroyed() : Boolean
            +getHp() : Integer
            +getSize() : Integer
            +getDirection() : Direction
            +getShipTiles() : Integer
            +setDirection(d : Direction)
            +hit()
            'We will only know the direction when placing the boat not during the creation
        }
        interface ShipFactory
        {
            +createShip(shipType : ShipType) : Ship
        }
        class AircraftCarrier extends Ship
        {
            +<<create>> AircraftCarrier()
        }
        class Cruiser extends Ship
        {
            +<<create>> Cruiser()
        }
        class Destroyer extends Ship
        {
            +<<create>> Destroyer()
        }
        class Submarine extends Ship
        {
            +<<create>> Submarine()
        }
        class TorpedoBoat extends Ship
        {
            +<<create>> TorpedoBoat()
        }

        class Weapon <<abstract>> implements PlacableObject
        {
            +<<create>>Weapon(type : WeaponType)
            +Use(opponentGrid : Grid, pos : Integer)
        }
        interface WeaponFactory
        {
            +createWeapon(weaponType : WeaponType) : Weapon
        }
        class Missile extends Weapon
        {
            +<<create>>Missile()
            +Use(opponentGrid : Grid, pos : Integer)
        }
        class Bomb extends Weapon
        { 
            +<<create>>Bomb()
            +Use(opponentGrid : Grid, pos : Integer)
        }
        class Sonar extends Weapon
        { 
            +<<create>>Sonar()
            +Use(opponentGrid : Grid, pos : Integer)
        }
        class Shovel extends Weapon
        {
            +<<create>>Shovel()
            +Use(opponentGrid : Grid, pos : Integer)
        }
        enum ShipType
        {
            AIRCRAFTCARRIER
            CRUISER
            DESTROYER
            SUBMARINE
            TORPEDOBOAT
        }
        enum Direction
        {
            HORIZONTAL
            VERTICAL
        }
        enum TrapType
        {
            BLACKHOLE
            TORNADO
        }
        enum WeaponType
        {
            MISSILE
            BOMB
            SONAR
            SHOVEL
        }
    }
    package player
    {
        class Player <<abstract>>
        {
            +<<create>>Player(grid : Grid)
            +PlaceBoatFix()
            +PlaceBoatRandom()
            +PlaceTrapFix()
            +PlaceTrapRandom()
            +PlaceWeaponRandom()
            +PlayTurn()
            +setWeaponStrategy(weapon : Weapon)
            +AddWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +removeObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +notifyEffectApplied(effect : Effects)
        }
        class Human extends Player
        {
            +<<create>>Human(grid : Grid)
            +PlaceBoatCustom(pos : Integer, ship : Ship)
            +PlaceTrapCustom(pos : Integer, trap : Trap)
            +PlaceWeaponCustom(pos : Integer, weapon : Weapon)
            +Attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }
        class AI extends Player
        {
            -m_tilesHit : Integer[*]
            +<<create>>AI(grid : Grid)
            +AttackRandom(opponentGrid : Grid,weapon : Weapon)
            +AttackWithTought(opponentGrid: Grid,weapon : Weapon)
        }

        interface PlayerObserver
        {
            void updateShips(ships : Ship[*]);
            void updateTraps(traps : Trap[*]);
            void updateWeapons(weapons : Weapon[*]);
            +updateAttack(pos : Integer, weapon : Weapon)
            +updateEffectApplied(effect : Effects)
        }
    }
    package game
    {
        class Game
        {
            -m_numberOfShips : Integer
            -m_turnNumber : Integer
            +<<create>> Game()
            +startGame()
            +nextTurn()
            +checkWin() : Boolean
            +getGameState() : GameState
            +getTurnNumber() : Integer
            +getNumberOfShips() : Integer
        }
        enum GameState
        {
            CONFIGURATION,
            PLACEMENT,
            PLAYING,
            END
        }
        interface GameObserver
        {
            +updateGameState(gamestate: GameState)
            +updateNumberOfShips(numberOfShips: Integer)
            +update(numberOfShips: Integer)
            +updateNumberOfShips(numberOfShips: Integer)
        }
    }
    package effects
    {
        interface Effects <<interface>>
        {
            +onBeforeAttack(player : Player)
            +isExpired() : Boolean
        }
        class TornadoEffect implements Effects
        {
            -remainingScrambles : Integer
            +<<create>>TornadoEffect()
            +getRemainingScrambles() : Integer
        }
    }
}

'Game relations
model.game.Game "1" *--> "-m_gameState" model.game.GameState: > is currently in
model.game.Game "2" o--> "-m_players" model.player.Player: > is played by
model.game.Game "1" o--> "-m_currentPlayer" model.player.Player : > current turn
model.game.Game "*" o--> "-m_gameObservers" model.game.GameObserver : > notifies

'Grid relations
model.grid.Grid "*" *--> "-m_grid" model.grid.Tile : > is made of

'Tile relations
model.grid.Tile "1" *--> "-m_object" model.placableObject.PlacableObject: > has elements of the type
model.grid.Tile *-> "1" model.grid.TileType : > is of the type\t

'Trap relations
model.placableObject.Trap "1" o--> "-m_trapTypе" model.placableObject.TrapType: > is of the type

'Ship relations
model.placableObject.Ship "1" o--> "-m_shipTyрe" model.placableObject.ShipType: > is of the type
model.placableObject.Ship "1" o--> "-m_direction" model.placableObject.Direction: > is in this direction

'Weapon relations
model.placableObject.Weapon "1" o--> "-m_weaponType" model.placableObject.WeaponType: > is of the typе
model.placableObject.Weapon ..> model.grid.Grid : <<uses>>

'Blackhole relations
model.placableObject.Blackhole ..> model.placableObject.Missile : <<uses>>
model.placableObject.Blackhole ..> model.grid.Grid : <<uses>>

'Tornado relations
model.placableObject.Tornado ..> model.grid.Grid : <<uses>>

'Player relations
model.player.Player "1" *--> "-m_ownGrid" model.grid.Grid : > places on
model.player.Player "*" *--> "-m_activeEffects" model.effects.Effects : > is affected by
model.player.Player "*" *--> "-m_ships" model.placableObject.Ship : > owns
model.player.Player "*" *--> "-m_traps" model.placableObject.Trap : > owns
model.player.Player "*" *--> "-m_weapons" model.placableObject.Weapon : > owns
model.player.Player "1" o--> "-m_weaponStrategy" model.placableObject.Weapon : > uses the strategy
model.player.Player "*" *--> "-m_ships" model.placableObject.Ship : > owns
model.player.Player "*" *--> "-m_traps" model.placableObject.Trap : > owns
model.player.Player "*" *--> "-m_weapons" model.placableObject.Weapon : > owns
model.player.Player "1" o--> "1..*" model.player.PlayerObserver : > notifies changes

'ShipFactory relations
model.placableObject.ShipFactory ..> model.placableObject.Ship : <<uses>>
model.placableObject.ShipFactory ..> model.placableObject.Submarine : <<instantiate>>
model.placableObject.ShipFactory ..> model.placableObject.TorpedoBoat : <<instantiate>>
model.placableObject.ShipFactory ..> model.placableObject.Cruiser : <<instantiate>>
model.placableObject.ShipFactory ..> model.placableObject.Destroyer : <<instantiate>>
model.placableObject.ShipFactory ..> model.placableObject.AircraftCarrier : <<instantiate>>

'WeaponFactory relations
model.placableObject.WeaponFactory .> model.placableObject.Weapon : <<uses>>
model.placableObject.WeaponFactory .> model.placableObject.Bomb : <<instantiate>>
model.placableObject.WeaponFactory .> model.placableObject.Sonar : <<instantiate>>
model.placableObject.WeaponFactory .> model.placableObject.Shovel : <<instantiate>>
model.placableObject.WeaponFactory .> model.placableObject.Missile : <<instantiate>>

'TrapFactory relations
model.placableObject.TrapFactory .> model.placableObject.Trap : <<uses>>
model.placableObject.TrapFactory .> model.placableObject.Blackhole : <<instantiate>>
model.placableObject.TrapFactory .> model.placableObject.Tornado : <<instantiate>>


' View relations
view.TerminalHistory .up.|> .model.player.PlayerObserver
view.PlacementScreen .up.|> .model.player.PlayerObserver
view.MainScreen .up.|> .model.player.PlayerObserver
view.EndScreen .up.|> .model.player.PlayerObserver

@enduml