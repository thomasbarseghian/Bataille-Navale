@startuml
skinparam style strictuml
skinparam classAttributelconSize 0
skinparam classFontStyle bold
hide enum methods
skinparam linetype ortho

package view
{
    class TerminalHistory
        {
            +<<create>>TerminalHistory()
            +updateAttack(pos : Integer, weapon : Weapon)
        }

        class ConfigurationScreen
        {
            +<<create>>ConfigurationScreen(controller : ConfigController)
            -handleStartPlacement()
            -initComponents()
        }

        class PlacementScreen
        {
            +<<create>>PlacementScreen(controller : PlacementController, playerGrid : Grid)
            +updateGameState(state : GameState)
            +updateTurnNumber(turnNumber : Integer)
            +updateHistory(logMessage : String)
        }

        class BattleScreen
        {
            +<<create>>BattleScreen(controller : BattleController)
            -selectWeapon(type : WeaponType)
            -updateWeaponLabel(type : WeaponType)
            -updateStats()
            +updateGameState(state : GameState)
            +updateTurnNumber(turnNumber : Integer)
            +updateHistory(logMessage : String)
        }

        class EndScreen
        {
            +<<create>>EndScreen(game : Game)
            +updateGameState(state : GameState)
            +updateTurnNumber(turnNumber : Integer)
            +updateHistory(logMessage : String)
            -generateStatsHTML(winner : Player) : String
        }
        class MainView
        {
            +<<create>>MainView(config : ConfigController, place : PlacementController, battle : BattleController, human : Player, ai : Player, game : Game)
            +showScreen(name : String)
        }
        class GridPanel
        {
            -m_hideShips : Boolean
            -m_size : Integer
            +<<create>>GridPanel(grid : Grid, hideShips : Boolean)
            -initLayout()
            +refreshGrid()
            -updateSingleTile(pos : Integer)
            +addInteractionListener(listener : Object)
            +updateTileHit(pos : Integer)
        }
}

package controller
{
    class ScreenController implements .model.game.GameObserver
    {
        +<<create>>ScreenController(view : MainView, game : Game)
        +updateGameState(state : GameState)
        +updateTurnNumber(turnNumber : Integer)
        +updateHistory(logMessage : String)
    }
    class BattleController
    {
        +<<create>>BattleController(humanLogic : HumanController, aiPlayer : Player)
        +onEnemyGridClicked(position : Integer)
        +onWeaponSelected(type : WeaponType) : Boolean
        +getHumanGrid() : Grid
        +getAiGrid() : Grid
        +getHumanStatsText() : String
        +getAiStatsText() : String
        -generateStatsHTML(p : Player, title : String) : String
    }
    class PlacementController
    {
        +<<create>>PlacementController(game : Game)
        +placeShipsFixed()
        -placeBonusItems(grid : Grid)
        +startGame()
    }
    class ConfigController
    {
        +<<create>>ConfigController(gameModel : Game)
        +applyConfiguration()
    }

    class HumanController extends WeaponCallback
    {
        +setGameController(gameController : GameController)
        +setPlayer(p : Player)
        +getPlayer() : Player
        +startTurn()
        +handleTileClick(target : Player, pos : Integer)
        +handleWeaponEquip(weaponType : WeaponType)
        +onAttackFinished()
    }
    class AIController extends WeaponCallback
    {
        +setGameController(gameController : GameController)
        +setOpponent(opponent : Player)
        +getPlayer() : Player
        +startTurn()
        +onAttackFinished()
    }

    interface TurnObserver <<interface>>{
        + onTurnEnded(Player p)
    }

    abstract class AbstractPlayerController <<abstract>>{
        +<<create>>AbstractPlayerController()
        +setPlayer(player : Player)
        +getPlayer() : Player
        +addObserver(observer : TurnObserver)
        +removeObserver(observer : TurnObserver)
        # notifyTurnEnded()
        + onAttackFinished()
        {abstract} + startTurn()
    }
    class GameController
    {
        +<<create>>GameController(game : Game, player : HumanController, ai : AIController)
        +setGame(game : Game)
        +onTurnEnded(playerWhoFinished : Player)
        -endHumanTurn()
        -endAiTurn()
        +onSpecialWeaponClicked(type : WeaponType)
        +onBombButtonClicked()
        +onTileClick(pos : Integer, targetPlayer : Player)
        +notifyAttackResult(attacker : Player, pos : Integer, weapon : WeaponType, isHit : Boolean)
    }
}

package model
{
    package grid
    {
        class Grid
        {
            -m_size : Integer
            +<<create>>Grid(size : Integer)
            +hitTile(pos:Integer)
            +putPlaceObjectInTile(object : PlaceableObject)
            +attackAt(pos : Integer, Weapon weapon) : PlaceableObject
            +addObserver(obs : GridObserver)
            +notifyTileHit(pos : Integer)
            +getTile(pos : Integer) : Tile
            +getSize() : Integer
            +isTileHit(pos : Integer) : Boolean
            +isLand(pos : Integer) : Boolean
            +getObjectAt(pos : Integer) : PlaceableObject
            +setTileHit(pos : Integer)
            -isValidPos(pos : Integer) : Boolean
            +reset()
            +getLandTiles() : Integer[*]
        }

        interface GridObserver <<interface>>
        {
            +updateTileHit(pos: Integer)
        }

        class Tile
        {
            -m_isHit : Boolean
            +<<create>>Tile(type : TileType)
            +hit()
            +isHit() : Boolean
            +isLand() : Boolean
            +getTileType() : TileType
            +getObject() : PlaceableObject
            +setObject(object : PlaceableObject)
            +isEmpty() : Boolean
            +reset()
        }
        enum TileType
        {
            WATER
            LAND
        }
    }
    package placeableObject
    {
        abstract PlaceableObject <<abstract>>
        {
            -m_position : Integer
            +<<create>>PlaceableObject(type : PlaceableObjectType)
            +getPosition() : Integer
            +setPosition(pos:Integer)
            +getObjectType():PlaceableObjectType
        }

        enum PlaceableObjectType
        {
            SHIP
            TRAP
            WEAPON
        }
        package trap
        {
            class Trap <<abstract>> implements model.placeableObject.PlaceableObject
            {
                +<<create>>Trap(type : TrapType)
                +activate(opponentGrid : Grid)
                +getTrapType() : TrapType
            }

            interface TrapFactory
            {
                +<<create>>TrapFactory()
                +createTrap(trapType : TrapType) : Trap
            }

            class Blackhole extends Trap
            {
                +<<create>>Blackhole()
                +activate(player : Player,pos : Integer)
            }
            class Tornado extends Trap
            {
                'An integer initialized to 0 will be created in the constructor, and each call to Scramble will increment this integer
                'by 1 until it reaches 3 (or a multiple of 3 if multiple Tornado traps can be placed on the same grid)
                -remainingScrambles : Integer
                +<<create>>Tornado()
                +activate(player : Player)
                +scramble(opponentGrid : Grid)
                +getRemainingScrambles() : Integer
                +isExpired() : Boolean
            }
            enum TrapType{
                BLACKHOLE
                TORNADO
            }
        }
        package ship
        {
            class Ship <<abstract>> implements model.placeableObject.PlaceableObject
            {
                -m_size : Integer
                -m_hp : Integer
                +<<create>> Ship(size : Integer, type : ShipType)
                'm_hp = size we don't need the information twice
                +isDestroyed() : Boolean
                +getHp() : Integer
                +getSize() : Integer
                +getDirection() : Direction
                +getShipType() : ShipType
                +setDirection(direction : Direction)
                +setHp(newhp : Integer)
                +hit()
                +getAllPositions():Integer[*]
                'We will only know the direction when placing the boat not during the creation
                +reset()
            }
            interface ShipFactory
            {
                +<<create>> ShipFactory()
                +createShip(shipType : ShipType) : Ship
            }
            class AircraftCarrier extends Ship
            {
                +<<create>> AircraftCarrier(size : Integer, type : ShipType)
            }
            class Cruiser extends Ship
            {
                +<<create>> Cruiser(size : Integer, type : ShipType)
            }
            class Destroyer extends Ship
            {
                +<<create>> Destroyer(size : Integer, type : ShipType)
            }
            class Submarine extends Ship
            {
                +<<create>> Submarine(size : Integer, type : ShipType)
            }
            class TorpedoBoat extends Ship
            {
                +<<create>> TorpedoBoat(size : Integer, type : ShipType)
            }
            enum ShipType
            {
                AIRCRAFTCARRIER
                CRUISER
                DESTROYER
                SUBMARINE
                TORPEDOBOAT
            }
            enum Direction
            {
                HORIZONTAL
                VERTICAL
            }
        }
        package weapon
        {
            class Weapon <<abstract>> extends model.placeableObject.PlaceableObject
            {
                +<<create>>Weapon(type : WeaponType)
                {abstract} +use(grid : Grid, pos : Integer)
                +setCallback(callback : WeaponCallback)
                +notifyFinished()
                +getType() : WeaponType
            }
            interface WeaponFactory
            {
                +<<create>>WeaponFactory()
                +createWeapon(weaponType : WeaponType) : Weapon
            }
            class Default extends Weapon
            {
                +<<create>>Default()
                +use(opponentGrid : Grid, pos : Integer)
            }
            class Bomb extends Weapon
            {
                +<<create>>Bomb()
                +getType() : WeaponType
                +use(grid : Grid, centerPos : Integer)
                -isInsideGrid(x : Integer, y : Integer, size : Integer) : Boolean
            }
            class Sonar extends Weapon
            {
                +<<create>>Sonar()
                +use(grid : Grid, pos : Integer)
            }
            enum WeaponType
            {
                DEFAULT
                BOMB
                SONAR
            }
        }
    }
    package player
    {
        class Player <<abstract>>
        {
            #m_name : String
            #m_isTornadoed : Boolean
            +<<create>>Player(name : String, grid : Grid, ships : Ship[*])
            +placeObject(object : PlaceableObject)
            {abstract} +placeShipFix()
            +placeShipRandom()
            +placeTrapFix()
            +placeTrapRandom()
            +placeWeaponFix()
            +placeWeaponRandom()
            +setWeaponStrategy(weapon : Weapon)
            +equipWeapon(targetType : WeaponType) : Boolean
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +setIsTornadoed(isAffected : Boolean)
            +attack(opponent : Player, pos : Integer)
            +addObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +getName() : String
            +getGrid() : Grid
            +getWeaponStrategy() : Weapon
            +allShipsAreSunk() : Boolean
            +getShips() : Ship[*]
            +reset()
        }
        class Human extends Player
        {
            +<<create>>Human(name : String, grid : Grid, ships : Ship[*])
            +placeShipFix()
            +placeBoatCustom(pos : Integer, ship : Ship)
            +placeTrapCustom(pos : Integer, trap : Trap)
            +placeWeaponCustom(pos : Integer, weapon : Weapon)
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }
        class AI extends Player
        {
            +<<create>>AI(name : String, grid : Grid, ships : Ship[*])
            +placeShipFix()
            +placeTrapFix()
            +setWeaponStrategy(weapon : Weapon)
            +addWeapon(weapon : Weapon)
            +addTrap(trap : Trap)
            +addObserver(observer : PlayerObserver)
            +notifyShipPlaced(ship : Ship)
            +notifyTrapPlaced(trap : Trap)
            +notifyAttack(pos : Integer, weapon : Weapon)
            +attackRandom(opponentGrid : Grid,weapon : Weapon)
            +attackWithTought(opponentGrid: Grid,weapon : Weapon)
            +attack(opponentGrid : Grid, pos : Integer, weapon : Weapon)
        }

        enum difficulty
        {
            RANDOM
            THOUGHT
        }
        interface PlayerObserver
        {
            +updateShips(ship : Ship)
            +updateTraps(trap : Trap)
            +updateWeapons(weapon : Weapon)
            +updateAttack(pos : Integer, weapon : Weapon)
        }
    }
    package game
    {
        class Game
        {
            -m_turnNumber : Integer
            -m_currentPlayer : Integer
            -m_winner : Player
            +<<create>> Game()
            +createStandardFleet(factory : ShipFactory) : Ship[]
            +recordMove(player : Player, position : Integer, weapon : WeaponType, isHit : Boolean)
            +startGame()
            +startPlacement()
            +startBattle()
            +nextTurn()
            +checkWin() : Boolean
            +stopGame(winner : Player)
            +getWinner() : Player
            +getGameState() : GameState
            +getTurnNumber() : Integer
            +getHumanPlayer() : Player
            +getAiPlayer() : Player
            +addObserver(obs : GameObserver)
            +notifyGameState(gamestate: GameState)
            +notifyTurnNumber(turnNumber: Integer)
            +notifyHistory(message : String)
            +restart()
        }
        enum GameState
        {
            CONFIGURATION,
            PLACEMENT,
            PLAYING,
            END
        }
        interface GameObserver <<interface>>
        {
            +updateGameState(gamestate: GameState)
            +updateTurnNumber(turnNumber: Integer)
            +updateHistory(logMessage: String)
        }
        class MoveData {
            -m_position : Integer[*]
            -m_m_isHit : Boolean[*]
            +<<create>> MoveData()
            +addData(position : Integer, hit : Integer, player : Player, weapon : WeaponType)
        }

        interface WeaponCallback <<interface>>{
            + onAttackFinished()
        }
    }
}
'PlaceableObject relations
model.placeableObject.PlaceableObject "1" *->  "-m_objectType" model.placeableObject.PlaceableObjectType : > is of the type\t
'Game relations
model.game.Game "1" *--> "-m_gameState" model.game.GameState: > is currently in
model.game.Game "2" o--> "-m_players" model.player.Player: > is played by
model.game.Game "*" o--> "-m_gameObserver" model.game.GameObserver : > notifies
model.game.Game "1" *--> "-m_moveHistory" model.game.MoveData : > has been played
model.game.Game "0..1" --> "-m_winner" model.player.Player : > has winner

'MoveData relations
model.game.MoveData "*" o--> "-m_player" model.player.Player: > move played by
model.game.MoveData "*" *--> "-m_weapon" model.placeableObject.weapon.Weapon: > move attacked with
model.game.MoveData ..> model.placeableObject.weapon.WeaponFactory : <<uses>>

'Grid relations
model.grid.Grid "1" *--> "-m_grid" model.grid.Tile : > is made of
model.grid.Grid "*" o--> "-m_gridObservers" model.grid.GridObserver : > notify

'Tile relations
model.grid.Tile "0..1" *--> "-m_object" model.placeableObject.PlaceableObject: > has elements of the type
model.grid.Tile "1" *->  "-m_tileType" model.grid.TileType : > is of the type\t

'Ship relations
model.placeableObject.ship.Ship "1" *--> "-m_shipType" model.placeableObject.ship.ShipType: > is of the type
model.placeableObject.ship.Ship "1" *--> "-m_direction" model.placeableObject.ship.Direction: > is in this direction

'Weapon relations
model.placeableObject.weapon.Weapon ..> model.grid.Grid : <<uses>>
model.placeableObject.weapon.Weapon "1" *->  "-m_weaponType" model.placeableObject.weapon.Weapon : > is of the type\t
model.placeableObject.weapon.Weapon "0..1" o->  "#m_callback" model.game.WeaponCallback : > calls back\t

'Trap relations
model.placeableObject.trap.Trap "1" *->  "-m_trapType" model.placeableObject.trap.TrapType : > is of the type

'Blackhole relations
model.placeableObject.trap.Blackhole ..> model.placeableObject.weapon.Default : <<uses>>
model.placeableObject.trap.Blackhole ..> model.grid.Grid : <<uses>>

'Tornado relations
model.placeableObject.trap.Tornado ..> model.grid.Grid : <<uses>>
model.placeableObject.trap.Tornado ..> model.player.Player : <<uses>>

'Player relations
model.player.Player "1" *--> "#m_grid" model.grid.Grid : > places on
model.player.Player "*" *--> "#m_ships" model.placeableObject.ship.Ship : > owns
model.player.Player "*" *--> "#m_traps" model.placeableObject.trap.Trap : > owns
model.player.Player "*" *--> "#m_weapons" model.placeableObject.weapon.Weapon : > owns
model.player.Player "1" o--> "#m_weaponStrategy" model.placeableObject.weapon.Weapon : > uses the strategy
model.player.Player "1..*" o--> "#m_observers" model.player.PlayerObserver : > notifies changes
model.player.Player ..> model.placeableObject.weapon.WeaponType : <<uses>>
model.player.Player ..> model.placeableObject.PlaceableObject : <<uses>>

'AI relations
model.player.difficulty .> model.player.AI : <<uses>>

'ShipFactory relations
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Ship : <<creates>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Submarine : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.TorpedoBoat : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Cruiser : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.Destroyer : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.AircraftCarrier : <<instantiate>>
model.placeableObject.ship.ShipFactory ..> model.placeableObject.ship.ShipType : <<uses>>

'WeaponFactory relations
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Weapon : <<creates>>
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Bomb : <<instantiate>>
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Sonar : <<instantiate>>
model.placeableObject.weapon.WeaponFactory .> model.placeableObject.weapon.Default : <<instantiate>>
model.placeableObject.weapon.WeaponFactory ..> model.placeableObject.weapon.WeaponType : <<uses>>

'TrapFactory relations
model.placeableObject.trap.TrapFactory .> model.placeableObject.trap.Trap : <<uses>>
model.placeableObject.trap.TrapFactory .> model.placeableObject.trap.Blackhole : <<instantiate>>
model.placeableObject.trap.TrapFactory .> model.placeableObject.trap.Tornado : <<instantiate>>
model.placeableObject.trap.TrapFactory ..> model.placeableObject.trap.TrapType : <<uses>>

' EndScreen also observes the gird
EndScreen ..|> model.grid.GridObserver
MainScreen ..|> model.grid.GridObserver

'Controller relations

'AbstractPlayerController relations
controller.AbstractPlayerController ..|> model.game.WeaponCallback
controller.AbstractPlayerController o--> "0..*" controller.TurnObserver : > notifies
controller.AbstractPlayerController "1" o--> "#m_player" model.player.Player : > controls
controller.AbstractPlayerController "*" o--> "#m_observers" controller.TurnObserver : > notifies

'AIController relations
controller.AIController --|> controller.AbstractPlayerController
controller.AIController "1" o--> "-gameController" controller.GameController : > notifies end of turn
controller.AIController "1" o--> "-m_opponent" model.player.Player : > targets
controller.AIController ..> model.placeableObject.weapon.Weapon : <<uses>>
controller.AIController ..> model.placeableObject.weapon.WeaponType : <<uses>>


'HumanController relations
controller.HumanController --|> controller.AbstractPlayerController
controller.HumanController "1" o--> "-gameController" controller.GameController : > notifies end of turn
controller.HumanController ..> model.placeableObject.weapon.Weapon : <<uses>>
controller.HumanController ..> model.placeableObject.weapon.WeaponType : <<uses>>

'GameController relations
controller.GameController ..|> controller.TurnObserver
controller.GameController "1" o--> "-m_humanController" controller.HumanController : > coordinates
controller.GameController "1" o--> "-m_aiController" controller.AIController : > coordinates
controller.GameController "1" o--> "-m_currentPlayer" model.player.Player : > tracks active player
controller.GameController ..> model.placeableObject.weapon.WeaponType : <<uses>>
controller.GameController "1" o--> "-m_game" model.game.Game : > is the active game
controller.GameController ..> model.placeableObject.weapon.WeaponType : <<uses>>

'BattleController relations
controller.BattleController "1" o--> "-m_humanLogic" controller.HumanController : > delegates to
controller.BattleController "1" o--> "-m_aiPlayer" model.player.Player : > targets

'ConfigController relations
controller.ConfigController "1" o--> "-gameModel" model.game.Game : > configures

'PlacementController relations
controller.PlacementController "1" o--> "-m_game" model.game.Game : > manages
' DÃ©pendance car il fait "new Bomb()"
controller.PlacementController ..> model.placeableObject.weapon.Bomb : <<instantiates>>

'ScreenController relations
controller.ScreenController ..|> model.game.GameObserver
controller.ScreenController "1" o--> "-m_view" view.MainView : > updates
controller.ScreenController "1" o--> "-m_game" model.game.Game : > observes

'View relations

'Dependencies and Relations
view.MainView "1" o--> "-configScreen" view.ConfigurationScreen : > manages
view.MainView "1" o--> "-placementScreen" view.PlacementScreen : > manages
view.MainView "1" o--> "-battleScreen" view.BattleScreen : > manages
view.MainView "1" o--> "-endScreen" view.EndScreen : > manages

view.ConfigurationScreen "1" o--> "-controller" controller.ConfigController : > uses

view.PlacementScreen "1" o--> "-m_controller" controller.PlacementController : > uses
view.PlacementScreen "1" o--> "-m_gridPanel" view.GridPanel : > contains
view.PlacementScreen ..|> model.game.GameObserver

view.BattleScreen "1" o--> "-m_controller" controller.BattleController : > uses
view.BattleScreen "1" o--> "-m_playerGridPanel" view.GridPanel : > contains
view.BattleScreen "1" o--> "-m_enemyGridPanel" view.GridPanel : > contains
view.BattleScreen ..|> model.game.GameObserver

view.EndScreen "1" o--> "-m_game" model.game.Game : > uses
view.EndScreen ..|> model.game.GameObserver

view.GridPanel "1" o--> "-m_gridModel" model.grid.Grid : > displays
view.GridPanel ..|> model.grid.GridObserver

@enduml